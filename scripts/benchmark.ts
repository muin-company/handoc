/**
 * Benchmark â€” measures parse and roundtrip times, saves results to docs/benchmark-results.md.
 * Always exits 0.
 */
import { readFileSync, writeFileSync, readdirSync, statSync } from 'fs';
import { join } from 'path';
import { HanDoc } from '../packages/hwpx-parser/src/handoc';
import { writeHwpx } from '../packages/hwpx-writer/src/index';

const ROOT = '/Users/mj/handoc';
const SIMPLE = join(ROOT, 'fixtures/hwpx/simple-text.hwpx');
const FIXTURES_DIR = '/Users/mj/handoc-fixtures/real-world';
const ITERATIONS = 5;

function findLargestHwpx(dir: string): string | null {
  let largest = '';
  let maxSize = 0;
  const walk = (d: string) => {
    try {
      for (const e of readdirSync(d)) {
        const full = join(d, e);
        const st = statSync(full);
        if (st.isDirectory()) walk(full);
        else if (e.toLowerCase().endsWith('.hwpx') && st.size > maxSize) {
          maxSize = st.size;
          largest = full;
        }
      }
    } catch { /* dir may not exist */ }
  };
  walk(dir);
  return largest || null;
}

async function bench(label: string, fn: () => Promise<void>, iterations = ITERATIONS): Promise<{ avg: number; min: number; max: number }> {
  const times: number[] = [];
  // warmup
  await fn();
  for (let i = 0; i < iterations; i++) {
    const start = performance.now();
    await fn();
    times.push(performance.now() - start);
  }
  return {
    avg: times.reduce((a, b) => a + b, 0) / times.length,
    min: Math.min(...times),
    max: Math.max(...times),
  };
}

function fmt(ms: number): string {
  return ms < 1000 ? `${ms.toFixed(1)}ms` : `${(ms / 1000).toFixed(2)}s`;
}

async function main() {
  const results: { label: string; avg: number; min: number; max: number; fileSize?: number }[] = [];

  // 1. Simple document parse
  const simpleBuf = new Uint8Array(readFileSync(SIMPLE));
  const r1 = await bench('Parse simple-text.hwpx', async () => { await HanDoc.open(simpleBuf); });
  results.push({ label: 'Parse simple-text.hwpx', ...r1, fileSize: simpleBuf.length });
  console.log(`âœ… ${results.at(-1)!.label}: avg ${fmt(r1.avg)}`);

  // 2. Complex document parse
  const complexPath = findLargestHwpx(FIXTURES_DIR);
  if (complexPath) {
    const complexBuf = new Uint8Array(readFileSync(complexPath));
    const name = complexPath.split('/').pop()!;
    const r2 = await bench(`Parse ${name}`, async () => { await HanDoc.open(complexBuf); });
    results.push({ label: `Parse complex (${name.slice(0, 40)})`, ...r2, fileSize: complexBuf.length });
    console.log(`âœ… ${results.at(-1)!.label}: avg ${fmt(r2.avg)}`);
  } else {
    console.log('âš ï¸  No complex document found, skipping');
  }

  // 3. Roundtrip (simple)
  const r3 = await bench('Roundtrip simple-text.hwpx', async () => {
    const doc = await HanDoc.open(simpleBuf);
    writeHwpx({ header: doc.header, sections: doc.sections }, doc.opcPackage);
  });
  results.push({ label: 'Roundtrip simple-text.hwpx', ...r3 });
  console.log(`âœ… ${results.at(-1)!.label}: avg ${fmt(r3.avg)}`);

  // 4. Roundtrip (complex)
  if (complexPath) {
    const complexBuf = new Uint8Array(readFileSync(complexPath));
    const name = complexPath.split('/').pop()!;
    const r4 = await bench(`Roundtrip ${name}`, async () => {
      const doc = await HanDoc.open(complexBuf);
      writeHwpx({ header: doc.header, sections: doc.sections }, doc.opcPackage);
    });
    results.push({ label: `Roundtrip complex (${name.slice(0, 40)})`, ...r4, fileSize: complexBuf.length });
    console.log(`âœ… ${results.at(-1)!.label}: avg ${fmt(r4.avg)}`);
  }

  // Generate markdown report
  let md = `# Benchmark Results\n\n`;
  md += `**Date:** ${new Date().toISOString().slice(0, 10)}  \n`;
  md += `**Iterations:** ${ITERATIONS}  \n`;
  md += `**Node:** ${process.version}  \n`;
  md += `**Platform:** ${process.platform} ${process.arch}\n\n`;
  md += `| Benchmark | Avg | Min | Max | File Size |\n`;
  md += `|-----------|-----|-----|-----|-----------|\n`;
  for (const r of results) {
    const size = r.fileSize ? `${(r.fileSize / 1024).toFixed(0)} KB` : '-';
    md += `| ${r.label} | ${fmt(r.avg)} | ${fmt(r.min)} | ${fmt(r.max)} | ${size} |\n`;
  }
  md += `\n---\n*Generated by \`npx tsx scripts/benchmark.ts\`*\n`;

  writeFileSync(join(ROOT, 'docs/benchmark-results.md'), md);
  console.log(`\nðŸ“Š Report saved to docs/benchmark-results.md`);
}

main().catch(e => {
  console.error('Benchmark error:', e);
});
