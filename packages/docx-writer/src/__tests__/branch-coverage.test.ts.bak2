import { describe, it, expect } from 'vitest';
import { __testing } from '../converter';
import type { GenericElement, DocumentHeader } from '@handoc/document-model';

/**
 * Target specific uncovered branches identified from coverage-final.json
 */

describe('Branch Coverage - Specific Uncovered Paths', () => {
  
  const createMockHeader = (): DocumentHeader => ({
    refList: { fontFaces: [], charProperties: [], paraProperties: [], borderFills: [] },
  } as any);

  describe('Branch 11 (line 122): fillBrush without winBrush child', () => {
    it('fillBrush with no children', () => {
      const borderFillEl: GenericElement = {
        tag: 'borderFill',
        attrs: { id: '1' },
        children: [{
          tag: 'fillBrush',
          attrs: {},
          children: [],  // No winBrush child
          text: '',
        }],
        text: '',
      };
      const parsed = __testing.parseBorderFill(borderFillEl);
      expect(parsed.bgColor).toBeUndefined();
    });

    it('fillBrush with non-winBrush children', () => {
      const borderFillEl: GenericElement = {
        tag: 'fillBrush',
        attrs: {},
        children: [{
          tag: 'otherChild',  // Not winBrush
          attrs: {},
          children: [],
          text: '',
        }],
        text: '',
      };
      const parsed = __testing.parseBorderFill({
        tag: 'borderFill',
        attrs: {},
        children: [borderFillEl],
        text: '',
      });
      expect(parsed.bgColor).toBeUndefined();
    });
  });

  describe('Branch 22-23 (lines 175-176): borderFill id without value', () => {
    it('borderFill element without id attribute', () => {
      const borderFillEl: GenericElement = {
        tag: 'borderFill',
        attrs: {},  // No id attribute
        children: [],
        text: '',
      };
      const id = parseInt(borderFillEl.attrs['id'] ?? '0');
      expect(id).toBe(0);  // Should use fallback '0'
    });
  });

  describe('Branch 24 (lines 180-182): empty headers', () => {
    it('convertHeaderFooterToDocxHeader with empty headers array', () => {
      const headers: any[] = [];  // Empty headers
      const result = __testing.convertHeaderFooterToDocxHeader(headers, createMockHeader());
      expect(result).toBeDefined();
    });
  });

  describe('Branch 25 (lines 183-185): empty footers', () => {
    it('convertHeaderFooterToDocxFooter with empty footers array', () => {
      const footers: any[] = [];  // Empty footers
      const result = __testing.convertHeaderFooterToDocxFooter(footers, createMockHeader());
      expect(result).toBeDefined();
    });
  });

  describe('Branch 26-28 (lines 193-196): convertSectionProperties defaults', () => {
    it('section properties without orientation', () => {
      const sectionProps = {
        pageWidth: 12240,
        pageHeight: 15840,
        landscape: false,  // Not landscape
        margins: {
          top: 1440,
          bottom: 1440,
          left: 1800,
          right: 1800,
          header: 720,
          footer: 720,
          gutter: 0,
        },
      };
      const result = __testing.convertSectionProperties(sectionProps as any);
      expect(result.page.size.orientation).toBeUndefined();
    });

    it('section properties with landscape', () => {
      const sectionProps = {
        pageWidth: 15840,
        pageHeight: 12240,
        landscape: true,  // Landscape mode
        margins: {
          top: 1440,
          bottom: 1440,
          left: 1800,
          right: 1800,
          header: 720,
          footer: 720,
          gutter: 0,
        },
      };
      const result = __testing.convertSectionProperties(sectionProps as any);
      expect(result.page.size.orientation).toBe('landscape');
    });
  });

  describe('Branch 29 (line 202): convertParagraphToDocx paraProp retrieval', () => {
    it('paragraph without paraPrIDRef', () => {
      const para = {
        paraPrIDRef: undefined,  // No para property ref
        pageBreak: false,
        runs: [{
          charPrIDRef: undefined,
          children: [{ type: 'text' as const, content: 'Test' }],
        }],
      };
      const result = __testing.convertParagraphToDocx(para as any, createMockHeader());
      expect(result.length).toBeGreaterThan(0);
    });

    it('paragraph with paraPrIDRef but not found in header', () => {
      const header: DocumentHeader = {
        refList: {
          fontFaces: [],
          charProperties: [],
          paraProperties: [
            { id: 999, align: 'left' },  // Different ID
          ],
          borderFills: [],
        },
      } as any;
      const para = {
        paraPrIDRef: 1,  // Not found in header
        pageBreak: false,
        runs: [{
          charPrIDRef: undefined,
          children: [{ type: 'text' as const, content: 'Test' }],
        }],
      };
      const result = __testing.convertParagraphToDocx(para as any, header);
      expect(result.length).toBeGreaterThan(0);
    });
  });

  describe('Branch 34 (line 254): convertParagraphToDocx with non-text children', () => {
    it('paragraph with non-text run children', () => {
      const para = {
        paraPrIDRef: undefined,
        pageBreak: false,
        runs: [{
          charPrIDRef: undefined,
          children: [
            { type: 'image' as const, src: 'test.png' },  // Not text type
          ],
        }],
      };
      const result = __testing.convertParagraphToDocx(para as any, createMockHeader());
      expect(result.length).toBeGreaterThan(0);
    });

    it('paragraph with mixed text and non-text children', () => {
      const para = {
        paraPrIDRef: undefined,
        pageBreak: false,
        runs: [{
          charPrIDRef: undefined,
          children: [
            { type: 'text' as const, content: 'Text' },
            { type: 'other' as const },  // Non-text type
            { type: 'text' as const, content: 'More text' },
          ],
        }],
      };
      const result = __testing.convertParagraphToDocx(para as any, createMockHeader());
      expect(result.length).toBeGreaterThan(0);
    });
  });

  describe('Additional uncovered edge cases', () => {
    it('borderFill with child tag that ends with :fillBrush but no winBrush', () => {
      const borderFillEl: GenericElement = {
        tag: 'borderFill',
        attrs: { id: '1' },
        children: [{
          tag: 'ns:fillBrush',  // Namespace prefix
          attrs: {},
          children: [{
            tag: 'notWinBrush',  // Not winBrush
            attrs: {},
            children: [],
            text: '',
          }],
          text: '',
        }],
        text: '',
      };
      const parsed = __testing.parseBorderFill(borderFillEl);
      expect(parsed.bgColor).toBeUndefined();
    });

    it('convertParagraphToDocx with empty runs array', () => {
      const para = {
        paraPrIDRef: undefined,
        pageBreak: false,
        runs: [],  // Empty runs
      };
      const result = __testing.convertParagraphToDocx(para as any, createMockHeader());
      expect(result.length).toBeGreaterThan(0);
    });
  });
});

  describe('Integration tests for hwpxToDocx branches', () => {
    it('document with headers (line 180)', async () => {
      const mockDoc = {
        metadata: { creator: 'Test', title: 'Test' },
        header: {
          refList: {
            fontFaces: [],
            charProperties: [],
            paraProperties: [],
            borderFills: [],
          },
        },
        headers: [{  // Non-empty headers
          type: 'both',
          paragraphs: [{
            paraPrIDRef: undefined,
            pageBreak: false,
            runs: [{
              charPrIDRef: undefined,
              children: [{ type: 'text' as const, content: 'Header' }],
            }],
          }],
        }],
        footers: [],  // Empty footers
        sections: [{
          sectionProps: undefined,  // No section props (line 193)
          paragraphs: [{
            paraPrIDRef: undefined,
            pageBreak: false,
            runs: [{
              charPrIDRef: undefined,
              children: [{ type: 'text' as const, content: 'Body' }],
            }],
          }],
        }],
        getImage: () => null,
      };
      
      // Mock Packer.toBuffer
      const originalPacker = require('docx').Packer;
      const mockToBuffer = async () => Buffer.from([]);
      originalPacker.toBuffer = mockToBuffer;
      
      // Mock HanDoc.open
      const originalHanDoc = require('@handoc/hwpx-parser').HanDoc;
      originalHanDoc.open = async () => mockDoc;
      
      const result = await __testing.hwpxToDocx(new Uint8Array([1, 2, 3]));
      expect(result).toBeDefined();
      
      // Restore
      delete originalPacker.toBuffer;
      delete originalHanDoc.open;
    });
  });
});
